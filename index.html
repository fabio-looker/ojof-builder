<!doctype html >
<html>
<head>
<title>LookML Builder</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/foundation/5.5.3/css/foundation.min.css" integrity="sha256-NTds7atVCDeolLUzbcl45lx4gJYO+hNXCaX1wC2HQHc=" crossorigin="anonymous" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/json-editor/0.7.28/jsoneditor.min.js" integrity="sha256-51+oMmpgSgS4jV5/DcGKnDHIOL6Jeie2i7ka6sPQVro=" crossorigin="anonymous"></script>
<!--<script src="https://cdnjs.cloudflare.com/ajax/libs/nunjucks/3.0.0/nunjucks.min.js" integrity="sha256-LWvp8rf/ha5W5zb5rGjypfi/b8w5Yo0Lm+W6ccH3ejA=" crossorigin="anonymous"></script>-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/dot/1.1.0/doT.min.js" integrity="sha256-0DJpUBhIByZ5Tm5u/xEvcRalEiuyadItx381FmBKHB4=" crossorigin="anonymous"></script>

<style>
 textarea{font-size:10pt !important;}
 .out {width:100%;height:20em;}
 dl.tabs.vertical>dd{overflow: hidden; text-overflow: ellipsis;}
</style>
<script>
	// Set the JSONEditor CSS theme and icon library globally
	JSONEditor.defaults.theme = 'foundation5';
	JSONEditor.defaults.iconlib = 'fontawesome4';
	$(document).ready(()=>{
			var editorDef= {
					schema: inputSchema,
					startval: tryJSONParse(qs("o")) || tryJSONParse(localStorage.getItem(storageKey)) || initialValue,
					"required_by_default":true,
					//"disable_collapse":true,
					"disable_properties":true,
					"display_required_only":true,
					"keep_oneof_values":true,
					"disable_edit_json":true
				}
			var editor = new JSONEditor($("#json-editor")[0],editorDef)
			editor.on('change',function() {
					localStorage.setItem(storageKey,JSON.stringify(editor.getValue()))
					$("#msg").hide()
				});
				
				doT.templateSettings = {
						evaluate:    /\<\<\!([\s\S]+?)\>\>/g,
						interpolate: /\<\<\:([\s\S]+?)\>\>/g,
						encode:      /\<\<&([\s\S]+?)\>\>/g,
						use:         /\<\<#([\s\S]+?)\>\>/g,
						define:      /\<\<##\s*([\w\.$]+)\s*(\:|=)([\s\S]+?)#\>\>/g,
						conditional: /\<\<\?(\?)?\s*([\s\S]*?)\s*\>\>/g,
						iterate:     /\<\<\*\s*(?:\>\>|([\s\S]+?)\s*\:\s*([\w$]+)\s*(?:\:\s*([\w$]+))?\s*\>\>)/g,
						varname: 'x',
						strip: false,
						append: true,
						selfcontained: false
					};	
			/* NJK var env=nunjucks.configure({
					tags: {
							blockStart: '<%',
							blockEnd: '%>',
							variableStart: '<$',
							variableEnd: '$>',
							commentStart: '<#',
							commentEnd: '#>'
						}
				});*/
			var templates={}
			$("script[type='text/x-dot-template']").each(function(i,el){
					var t=this.dataset;
					//templates[t.name]=nunjucks.compile($(this).text(),env)
					templates[t.name]=doT.template($(this).text())
					$("#out").append("<h2>"+(t.label||t.name)+"</h2><textarea readonly='readonly' class='out' data-name='"+t.name+"'></textarea>")
				})

			$("#text-out").focus(function(){
					// Highlight all on select
					// Solution per http://stackoverflow.com/a/24589806
					$(this).on("click.a keyup.a", function(e){
							$(this).off("click.a keyup.a").select();
						});
				});



			$("#build-form").on("submit",function(evt){
					evt.preventDefault();
					$("#msg").hide();
					var errs=editor.validate();
					if(errs.length){
							$("#msg")
							.text(errs.map(e=>e.path+": "+e.message).join("\n"))
							.show()
							return;
						}
					var editorValue=editor.getValue()
					console.log("Editor", editorValue)
					var input=customTransform(editorValue)
					console.log("transformed", input)
					$(".out").each(function(i,el){
							try{
									$(this).val(templates[this.dataset.name](input).replace(/\n\s*\n/g,"\n"))
								}catch(e){
									console.error(e)
								}
						})
				})
		})
	
	//Just functions below

	function set(obj,path,val){
			if(path.split){path=path.split('.')}
			var head=path[0];
			if(path.length==1){
					obj[head]=val
				}else{
					obj[head]=obj[head]||{};
					set(obj[head],path.slice(1),val)
				}
			return obj;
		}
	function get(obj,path){
			if(path.split){path=path.split('.')}
			var head=path[0];
			if(path.length==1){
					return obj && obj[head];
				}else{
					return get(obj[head],path.slice(1))
				}
		}
	function unique(x,i,a){return a.indexOf(x)===i}
	function not(f){return function(...argArr){return !f(...argArr)}}
	function flatten(a,b){return a.concat(b)}
	function truthy(x){return !!x}
	function objByOf(byKeys,ofKey){
			byKeys=(byKeys instanceof Array ? byKeys : [byKeys])
			return function(accum,x,i){
					return set(accum,byKeys.map(k=>get(x,k)),ofKey?get(x,ofKey):x)
				}
		}
	function sorter(path){
			return function(a,b){
					return get(a,path)-get(b,path)
				}
		}
	function tryJSONParse(s){
			try{
					return JSON.parse(s)
				}catch(e){
					return undefined
				}
		}
	function qs(k){
			return document.location.search.slice(1).split("&")
			.filter(function(p){return p.indexOf(encodeURIComponent(k)+"=")===0})
			.map(function(p){return decodeURIComponent(p.split("=").slice(1).join("="))})[0]
		}
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-96247573-1', 'auto');
  ga('set', 'checkProtocolTask', null); // Disable file protocol checking.
  ga('set', 'checkStorageTask', null); // Disable cookie storage checking.
  ga('set', 'historyImportTask', null); // Disable history checking (requires reading from cookies).
  ga('send', 'pageview');

</script>
</head>
<body>
	<h1>LookML Builder</h2>
	<div>
		<div id="build-panel" style="width:80vw;min-width:640px;margin:0 auto">
			<form id="build-form" onsubmit="return false">
				<div id="json-editor"></div>
				<div id="msg" style="white-space:pre-line;color:#333;background-color:#DDB"></div>
				<div style="text-align:right">
					<div  style="display:inline-block;vertical-align:top;margin: 0 2em;">
						<input type="submit" style="margin-left:auto;margin-right:auto;border:solid 1px black" value="Go" class="button" />
					</div>
				</div>
			</form>
		</div>
		<div style="max-width:640px;margin:0 auto">
			<h2>Tips</h2>
			<ul style="font-size:0.8em; font-family:serif; color:#333;">
				<li> This is a static HTML file and can be used locally. If you are running it from a shared domain, other scripts on that domain may have access to data you enter here.</li>
			</ul>
		</div>
		<div style="width:80vw;min-width:640px;margin:0 auto">
			<h2>Built Model</h2>
			<div id="out"></div>
		</div>
	</div>
</body>
<!-- Input schema-->
<script>
	var storageKey="json-outerjoinonfalse"
	var pat={
			sql:"^[^;]+(;[^;]+)*$",
			oneLineString:"^[^\"\\n]+$",
			multiLineStringPattern:"^[^\"]+$",
			atom:"^[a-zA-Z0-9_]+$",
			atomOrNone:"^[a-zA-Z0-9_]*$"
		}
	var inputSchema={
			type:"object",
			title:"LookML Builder Form",
			options:{"disable_edit_json":false,"disable_properties":false,"remove_empty_properties":true,"display_required_only":true},
			properties:{
					"connectionName":{
							title:"Name of your connection",
							type:"string",
							pattern:pat.oneLineString
						},
					"dialect":{
							title:"SQL Dialect",
							type:"string",
							enum:["BigQuery Standard","Redshift"]
						},
					"explore":{
						title:"Explore Label",
						type:"string",
						pattern:pat.oneLineString
					},
					"views":{
							title:"Views",
							type:"array",
							format:"tabs",
							items:{
									type:"object",
									title:"View",
									headerTemplate:"{{self.label}}\n{{self.table}}",
									options:{disable_collapse:true},
									properties:{
											"label":{title:"Label",type:"string", pattern:pat.oneLineString},
											"table":{title:"Table",type:"string", pattern:pat.sql},
											"pk":{
													type:"object",
													title:"Primary Key",
													properties:{
															key:{title:"Key",type:"string", pattern:pat.atom}, //v2: Comma-separated atoms
															dim:{type:"boolean",format:"checkbox",title:"Dimension"},
															count:{type:"boolean",format:"checkbox",title:"Count"}
														}
												},
											"rs":{
													type:"object",
													format:"compact",
													title:"[Redshift only]",
													properties:{
															dist:{title:"Dist key",type:"string", pattern:pat.atomOrNone},
															sort:{title:"Sort key",type:"string", pattern:pat.atomOrNone}
														}
												},
											"fields":{
													type:"array",
													format:"tabs",
													title:"Fields",
													items:{
															type:"object",
															title:"Field",
															headerTemplate:"{{self.label}}",
															options:{disable_collapse:true},
															properties:{
																	label:{title:"Label",type:"string", pattern:pat.oneLineString},
																	sql:{title:"SQL",type:"string", pattern:pat.sql},
																	dim:{type:"boolean",format:"checkbox",title:"Dimension"},
																	sum:{type:"boolean",format:"checkbox",title:"Sum"},
																	avg:{type:"boolean",format:"checkbox",title:"Average"},
																	min:{type:"boolean",format:"checkbox",title:"Min"},
																	max:{type:"boolean",format:"checkbox",title:"Max"},
																	list:{type:"boolean",format:"checkbox",title:"List"},
																	"otherLookml":{title:"Other LookML", type:"string", format:"textarea"}
																}
														}
												}
										}
								}
						},
					"normalizedRelationships":{
							title:"Normalized relationships",
							type:"array",
							format:"table",
							options:{disable_array_delete_last_row:true,disable_array_delete_all_rows:true,disable_array_reorder:true},
							items:{
									type:"object",
									properties:{
											leftViewName:{
													type:"string",
													title:"\"Many\" Table",
													options:{input_width:"12em"},
													watch:{views:"views"},
													enumSource:[{
															source:"views",
															title:"{{item.label}} ({{item.table}})",
															value:"{{item.label}}_{{i}}"
														}]
												},
										 	foreignKey:{
												type:"string",
												title:"ManyTable.FK",
												options:{input_width:"28em"},
												pattern:pat.atom},
											rightViewName:{
													type:"string",
													title:"\"One\" Table",
													options:{input_width:"12em"},
													watch:{views:"views"},
													enumSource:[{
															source:"views",
															title:"{{item.label}} ({{item.table}})",
															value:"{{item.label}}_{{i}}"
														}]
												}
										}
								}
						},
					"conformedRelationships":{
							title:"Conformed relationships",
							type:"array",
							format:"tabs",
							//options:{},
							items:{
									type:"object",
									title:"Relationship",
									headerTemplate:"{{self.Label}}",
									options:{disable_collapse:true},
									properties:{
										name:{type:"string",title:"Label"},
										type:{type:"string",title:"Type",enum:["Date","Other"]}
										//timeframes
										//conformedColumns:{type:"array"}
									}
								}
						},
					"timeframes":{
							title:"Timeframes",
							type:"array",
							uniqueItems:true,
							items:{
									type:"string",
									enum:[
											"year",
											"month",
											"week",
											"day",
											"hour",
											"hour_of_day",
											"day_of_week",
											"month_of_year"
										]
								}
						},
					"pdtPersistence":{
							title:"PDT Persistence (if any)",
							type:"string",
							pattern:"^$|^persist_for:\\s*\"\\d+\\s+(hours?|days?|minutes?)\"$|^sql_trigger_value:[^;]*(;[^;]*)*;;$"
						}
				}
		}

	var initialValue={}
	
	function customTransform (x){
			return Object.assign({},x,{
					explore:{
							label:x.explore,
							name:lookmlName(x.explore)
						},
					views:x.views.map((v,vi)=>Object.assign({},v,{
							n:vi,
							name:lookmlName(v.label)+"_"+vi,
							mName:lookmlName(v.label)+"_"+vi+"m",
							dName:lookmlName(v.label)+"_"+vi+"d",
							isTableRef:!!v.table.match(/^\s*[a-zA-Z_][a-zA-Z0-9_$]*\s*$/),
							fields:v.fields.map((f,fi)=>Object.assign({},f,{
									n:fi,
									viewName:lookmlName(v.label)+"_"+vi,
									name:lookmlName(f.label)+"_"+fi,
									sql:f.sql.match(/^[_a-zA-Z][_a-zA-Z0-9$]*$|^"[^"]+"$/)?"${TABLE}."+f.sql:f.sql
								}))
						})),
					normalizedRelationships:x.normalizedRelationships.map((r,ri)=>Object.assign({},r,{
							leftViewName:lookmlName(r.leftViewName),
							rightViewName:lookmlName(r.rightViewName),
						}))
				});
		}
	// "Custom functions" for use in this template. Pure funtions go here, fn's w/closures go in the template...
	function lookmlName(s){
			return s.replace(/[\s]+/g,"_").replace(/[^a-zA-Z0-9_]+/g,"").toLowerCase()
		}
	function measureNames(view){
			return (["sum","avg","min","max","list"]
					.map(measureType=>view.fields.map(field=>field[measureType] && measureType+"_"+field.name))
					.reduce(flatten,["count_pk"])
					.filter(truthy)
				)
		}
	function measurePaths(view){
			return measureNames(view).map(field=>view.mName+"."+field)
		};
	function dimensionNames(view){
			return (["dim","dg"]
					.map(dimensionType=>view.fields.map(field=>field[dimensionType] && dimensionType+"_"+field.name))
					.reduce(flatten,["pk"])
					.filter(truthy)
				)
		};
	function dimensionPaths(view){
			return dimensionNames(view).map(field=>view.dName+"."+field)
		};

</script>
<script type="text/x-dot-template" data-name="main">
	<<!
	function parentViewNames() {}
	function ancestorViews(targetView){
			var targetViewName=typeof targetView == "string" ? targetView : targetView.name;
			return recurAncestorNames(targetViewName,6).filter(unique).map(name=>x.views.find(v=>v.name==name));
		
			function recurAncestorNames(targetViewName,remainingRecursion){
					var parentViewNames
							=x.normalizedRelationships
							.filter(rel=>rel.rightViewName==targetViewName)
							.map(rel=>rel.leftViewName);
					return (parentViewNames.length && remainingRecursion
							? parentViewNames.map(p=>recurAncestorNames(p,remainingRecursion-1)).reduce(flatten,parentViewNames)
							: []
						);
				}
			
		};
	>>
	
	connection: "<<:x.connectionName>>"
	explore: <<:x.explore.name>> {
		label:"<<:x.explore.label>>"

		# "Measure" joins
		<<* x.views :view:v >>
		join: <<:view.mName>> {
			from: <<:view.name>>
			type: full_outer
			relationship: one_to_one
			fields: [measures*]
			<<? x.dialect=="BigQuery Standard" >>
			sql_on: FALSE ;;
			<<?? x.dialect=="Redshift" >>
			#Redshift (Only allows FOJ on merge joins, which require dist & sort key equality)
			sql_on: /**/
				    ${<<:view.mName>>.dist} = ${<<:x.explore.name>>.base}
				AND ${<<:view.mName>>.sort} = ${<<:x.explore.name>>.base} 
				<<* x.views.filter(prior=>prior.n<view.n) :prior:p >>
				{%  <<* x.views
						.filter(pp=>pp.n<=prior.n)
						.map(pp=>[]
								.concat(measurePaths(pp))
								.concat(dimensionPaths(pp))
							)
						.reduce(flatten,[])
						 :field:f >>
					<<?f==0>>if<<??>>or<<?>> <<:field>>._in_query or <<:field>>._in_filter
					<<*>>
				%}
				AND ${<<:view.mName>>.dist} = ${<<:prior.mName>>.dist}
				AND ${<<:view.mName>>.sort} = ${<<:prior.mName>>.sort}
				{% endif %}
				<<*>>
			;;
	 		<<?>>
		}
		<<*>>
		

		#"Dimension table" joins
		<<* x.views :view >>
		join: <<:view.name>>n {#Null dimension
			from: <<:view.name>>
			required_joins:[
				
			]
			fields:[]
			relationship: one_to_one
			sql_on:{%
				<<* []
				.concat(measurePaths(view))
				.concat(dimensionPaths(view))
				.concat(ancestorViews(view).map(aView=>measurePaths(aView)))
				.concat(ancestorViews(view).map(aView=>dimensionPaths(aView)))
				:field:f>>
				<<?f==0>>if<<??>>or<<?>> <<:field>>._in_query or <<:field>>._in_filter
				<<*>>
				%} LEFT JOIN (
					SELECT NULL as <<:view.pk.key>>
					<<* x.normalizedRelationships.filter(rel=>rel.leftViewName==view.name) :rel>>
					,NULL as <<:rel.foreignKey>>
					<<*>>
					FROM (SELECT NULL x ) X WHERE x IS NOT NULL 
				) as <<:view.dName>> ON FALSE /*
				{% else %} --*/ {% endif %}
			;;
		}
		join: <<:view.dName>> {
			from: <<:view.name>>
			type: left_outer
			relationship: many_to_one
			fields:[dimensions*]
			required_joins:[
				<<:view.name>>a
				<<* ancestorViews(view) :aView:a>>
				,<<:aView.dName>>
				<<*>>
			]
			
			sql_on: ${<<:view.dName>>.pk}=COALESCE(
				<<* x.normalizedRelationships
					.filter(rel=>rel.rightViewName==view.name)
					:rel>>
					<<! let parentView=x.views.find(v=>v.name==rel.leftViewName); >>
					{%
						<<* dimensionPaths(parentView)
							.concat(ancestorViews(parentView).map(dimensionPaths).reduce(flatten,[]))
							.concat(ancestorViews(parentView).map(measurePaths).reduce(flatten,[]))
							:field:f >>
						<<?f==0>>if<<??>>or<<?>> <<:field>>._in_query or <<:field>>._in_filter
						<<*>>
					%}<<:parentView.dName>>.<<:rel.foreignKey>>,{% endif %}
					{%
						<<* measurePaths(parentView) :measure:m >>
						<<?m==0>>if<<??>>or<<?>> <<:measure>>._in_query or <<:measure>>._in_filter
						<<*>>
					%}<<:parentView.mName>>.<<:rel.foreignKey>>,{% endif %}
				<<*>>
				${<<:view.mName>>.pk}
			)
			-- */
			;;
			#V2: RS: Add checkboxes to rel object for dist & sort equality constraints
		}
		<<*>>
		
	}

	#"Base" (empty) View
	view: <<:x.explore.name>> {
		view_label: "[<<:x.explore.label>>]"
		<<? x.dialect=="BigQuery Standard">> #BQ
		sql_table_name: (SELECT base FROM (SELECT null as base) as btable WHERE base IS NOT NULL);;
		<<?? x.dialect=="Redshift">> #Redshift
		derived_table: {
			sql: (SELECT base FROM (SELECT null as base) as btable WHERE base IS NOT NULL) ;;
			persist_for: "120 hours"
			distribution: "base"
			sortkeys: ["base"]
		}
		<<?>>
		dimension: base {
			hidden: yes
			sql: ${TABLE}.base ;;
		}
		# TODO
		#dimension_group: combined {
		#	type: time
		#	timeframes: [date,week,month]
		#	sql: ${combined_date_internal} ;;
		#}
		#dimension: combined_date_internal {
		#	hidden: yes
		#	sql: COALESCE({%
		#	  if pageviews.count._in_query
		#	  or all_the_things.product_conversion_rate._in_query
		#	  %}
		#	  pageviews.pv_date, {% endif %}{%
		#	  if orders.count._in_query
		#	  or orders.total_sales._in_query
		#	  or all_the_things.product_conversion_rate._in_query
		#	  %}
		#	  CASE {% parameter orders.combined_date_on %}
		#	  WHEN 'Order Date' THEN orders.order_date
		#	  WHEN 'Shipped Date' THEN orders.shipped_date
		#	  ELSE orders.order_date
		#	  END, {% endif %}
		#	  CAST(NULL as timestamp)
		#	);;
		#}
		#measure: product_conversion_rate {
		#	type: number
		#	value_format_name: decimal_3
		#	sql: CASE WHEN ${pageviews.count}<>0 THEN ${orders.count} / ${pageviews.count} ELSE NULL END;;
		#}
		#
	}

 
	<<* x.views :view >>
	view: <<:view.name>> {
		label: "<<:view.label>>"
		<<?view.isTableRef>>
		sql_table_name: <<:view.table>>;;
		<<??>>
		derived_table: {
			<<:x.pdtPersistence>>
			<<?x.dialect=="Redshift">>
			distribution: "<<:view.rs.dist>>"
			indexes: ["<<:view.rs.sort>>"]
			<<?>>
			sql:<<:view.table>>;;
		}
		<<?>>
		<<?x.dialect=="Redshift">>
		dimension: dist{
			hidden: yes
			sql:${TABLE}.<<:view.rs.dist>>;;
		}
		dimension: sort{
			hidden: yes
			sql:${TABLE}.<<:view.rs.sort>>;;
		}
		<<?>>
		# PK Fields
		dimension: pk {
			hidden: <<:view.pk.dim ? "no" : "yes">>
			label: "<<:view.label>> ID"
			sql: ${TABLE}.<<:view.pk.key>>;;
		}
		measure: count_pk {
			hidden: <<:view.pk.count ? "no" : "yes">>
			type: number
			sql: CASE WHEN MIN(${pk}) IS NULL THEN NULL ELSE COUNT(${pk}) END ;;
		}
		##
		## Measure Fields
		##
		set: measures{
			fields:[
				<<* measureNames(view) :measure:m>>
				<<?m>0>>,<<?>> <<:measure>>
				<<*>>
			]
		}
		<<*view.fields :field>>
		<<?field.sum>> 
		measure: sum_<<:field.name>> {
			type: number
			label: "Sum of <<:field.label>>"
			sql: SUM(<<:field.sql>>) ;;
			<<:field.otherLookml>>
		}
		<<?>>
		
		<<?field.avg>> 
		measure: avg_<<:field.name>> {
			type: number
			label: "Average of <<:field.label>>"
			sql: AVG(<<:field.sql>>) ;;
			<<:field.otherLookml>>
		}
		<<?>>
		
		<<?field.min>> 
		measure: min_<<:field.name>> {
			label: "Min of <<:field.label>>"
			sql: MIN(<<:field.sql>>) ;;
			<<:field.otherLookml>>
		}
		<<?>>
		
		<<?field.max>> 
		measure: max_<<:field.name>> {
			label: "Max of <<:field.label>>"
			sql: MAX(<<:field.sql>>) ;;
			<<:field.otherLookml>>
		}
		<<?>>
		
		<<?field.list>> 
		measure: list_<<:field.name>> {
			label: "List of <<:field.label>>"
			<<? x.dialect=="Redshift">>sql: LISTAGG(<<:field.sql>>,', ') ;;<<?>>
			<<? x.dialect=="BigQuery Standard">>sql: GROUP_CONCAT(<<:field.sql>>) ;;<<?>>
			<<:field.otherLookml>>
		}
		<<?>>
		<<*>>
		
		#
		# Dimension Fields
		#
		set: dimensions{
			fields:[
				<<* dimensionNames(view) :dimension:d>>
				<<?d>0>>,<<?>> <<:dimension>>
				<<*>>
			]
		}
		<<* view.fields :field>>
		<<?field.dim>> 
		dimension: dim_<<:field.name>> {
			label: "<<:field.label>>"
			sql: <<:field.sql>> ;;
			<<:field.otherLookml>>
		}
		<<?>>
		<<?field.dg>> #TODO
		dimension_group: dg_<<:field.name>> {
			group_label: "<<:field.label>>"
			timeframes: [<<:timeframes.join(",")>>]
			sql: <<:field.sql>> ;;
			<<:field.otherLookml>>
		}
		<<?>>
		<<*>>
	}
	<<*>>
</script>
</html>
