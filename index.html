<!doctype html >
<html>
<head>
<title>LookML Builder</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/foundation/5.5.3/css/foundation.min.css" integrity="sha256-NTds7atVCDeolLUzbcl45lx4gJYO+hNXCaX1wC2HQHc=" crossorigin="anonymous" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/json-editor/0.7.28/jsoneditor.min.js" integrity="sha256-51+oMmpgSgS4jV5/DcGKnDHIOL6Jeie2i7ka6sPQVro=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/nunjucks/3.0.0/nunjucks.min.js" integrity="sha256-LWvp8rf/ha5W5zb5rGjypfi/b8w5Yo0Lm+W6ccH3ejA=" crossorigin="anonymous"></script>

<style>
 textarea{font-size:10pt !important;}
 .out {width:100%;height:20em;}
</style>
<script>
	// Set the JSONEditor CSS theme and icon library globally
	JSONEditor.defaults.theme = 'foundation5';
	JSONEditor.defaults.iconlib = 'fontawesome4';
	$(document).ready(()=>{
			var editorDef= {
					schema: inputSchema,
					startval: tryJSONParse(qs("o")) || tryJSONParse(localStorage.getItem(storageKey)) || initialValue,
					"required_by_default":true,
					//"disable_collapse":true,
					"disable_properties":true,
					"display_required_only":true,
					"keep_oneof_values":true,
					"disable_edit_json":true
				}
			var editor = new JSONEditor($("#json-editor")[0],editorDef)
			editor.on('change',function() {
					localStorage.setItem(storageKey,JSON.stringify(editor.getValue()))
					$("#msg").hide()
				});
				
				
			var env=nunjucks.configure({
					tags: {
							blockStart: '<%',
							blockEnd: '%>',
							variableStart: '<$',
							variableEnd: '$>',
							commentStart: '<#',
							commentEnd: '#>'
						}
				});
			var templates={}
			$("script[type='text/x-nunjucks']").each(function(i,el){
					var t=this.dataset;
					templates[t.name]=nunjucks.compile($(this).text(),env)
					$("#out").append("<h2>"+(t.label||t.name)+"</h2><textarea readonly='readonly' class='out' data-name='"+t.name+"'></textarea>")
				})

			$("#text-out").focus(function(){
					// Highlight all on select
					// Solution per http://stackoverflow.com/a/24589806
					$(this).on("click.a keyup.a", function(e){
							$(this).off("click.a keyup.a").select();
						});
				});



			$("#build-form").on("submit",function(evt){
					evt.preventDefault();
					$("#msg").hide();
					var errs=editor.validate();
					if(errs.length){
							$("#msg")
							.text(errs.map(e=>e.path+": "+e.message).join("\n"))
							.show()
							return;
						}
					var editorValue=editor.getValue()
					
					$(".out").each(function(i,el){
							$(this).val(templates[this.dataset.name].render(editorValue))
						})
				})
		})
	
	//Just functions below

	function set(obj,path,val){
			if(path.split){path=path.split('.')}
			var head=path[0];
			if(path.length==1){
					obj[head]=val
				}else{
					obj[head]=obj[head]||{};
					set(obj[head],path.slice(1),val)
				}
			return obj;
		}
	function get(obj,path){
			if(path.split){path=path.split('.')}
			var head=path[0];
			if(path.length==1){
					return obj && obj[head];
				}else{
					return get(obj[head],path.slice(1))
				}
		}

	function objByOf(byKeys,ofKey){
			byKeys=(byKeys instanceof Array ? byKeys : [byKeys])
			return function(accum,x,i){
					return set(accum,byKeys.map(k=>get(x,k)),ofKey?get(x,ofKey):x)
				}
		}
	function sorter(path){
			return function(a,b){
					return get(a,path)-get(b,path)
				}
		}

	function nonce(len) {
			var text = "";
			var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
			for (var i = 0; i < len; i++){
					text += possible.charAt(Math.floor(Math.random() * possible.length));
				}
			return text;
		}
	function autoLabel(name){
			return name.replace(/(^|_)([a-z])/g,s=>s.toUpperCase()).replace(/_/g," ")
		}
		
	function pathBuilderObjectToString(obj){
		
		
		
		
		}
	function tryJSONParse(s){
			try{
					return JSON.parse(s)
				}catch(e){
					return undefined
				}
		}
	function qs(k){
			return document.location.search.slice(1).split("&")
			.filter(function(p){return p.indexOf(encodeURIComponent(k)+"=")===0})
			.map(function(p){return decodeURIComponent(p.split("=").slice(1).join("="))})[0]
		}
</script>
<!-- templating functions -->
<script>
function lookmlName(s){
		return s.replace(/[^a-zA-Z0-9_]+/g,"").toLowerCase()
	}
	
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-96247573-1', 'auto');
  ga('set', 'checkProtocolTask', null); // Disable file protocol checking.
  ga('set', 'checkStorageTask', null); // Disable cookie storage checking.
  ga('set', 'historyImportTask', null); // Disable history checking (requires reading from cookies).
  ga('send', 'pageview');

</script>
</head>
<body>
	<h1>LookML Builder</h2>
	<div>
		<div id="build-panel" style="width:80vw;min-width:640px;margin:0 auto">
			<form id="build-form">
				<div id="json-editor"></div>
				<div id="msg" style="white-space:pre-line;color:#333;background-color:#DDB"></div>
				<div style="text-align:right">
					<div  style="display:inline-block;vertical-align:top;margin: 0 2em;">
						<input type="submit" style="margin-left:auto;margin-right:auto;border:solid 1px black" value="Go" class="button" />
					</div>
				</div>
			</form>
		</div>
		<div style="max-width:640px;margin:0 auto">
			<h2>Tips</h2>
			<ul style="font-size:0.8em; font-family:serif; color:#333;">
				<li> This is a static HTML file and can be used locally. If you are running it from a shared domain, other scripts on that domain may have access to data you enter here.</li>
			</ul>
		</div>
		<div style="width:80vw;min-width:640px;margin:0 auto">
			<h2>Built Model</h2>
			<div id="out"></div>
		</div>
	</div>
</body>
<!-- Input schema-->
<script>
	var storageKey="json-outerjoinonfalse"
	var inputSchema={
			type:"object",
			title:"LookML Builder Form",
			options:{"disable_edit_json":false,"disable_properties":false,"remove_empty_properties":true,"display_required_only":true},
			properties:{
					"connectionName":{
							title:"Name of your connection",
							type:"string"
						},
					"dialect":{
							title:"SQL Dialect",
							type:"string",
							enum:["BigQuery Standard","Redshift"]
						},
					"exploreName":{
						title:"Explore name",
						type:"string"//,
						//required:false
					},
					"views":{
							title:"Views",
							type:"array",
							format:"tabs",
							items:{
									type:"object",
									title:"View",
									headerTemplate:"{{self.label}}",
									options:{disable_collapse:true},
									properties:{
											"label":{title:"Label",type:"string"},
											"table":{title:"Label",type:"string"},
											"pk":{title:"Primary Key",type:"string"},
											"rs":{
													type:"object",
													format:"compact",
													title:"[Redshift only]",
													properties:{
															dist:{title:"Dist key",type:"string"},
															sort:{title:"Sort key",type:"string"}
														}
												},
											"dimensions":{
													type:"array",
													format:"tabs",
													title:"Dimensions",
													items:{
															type:"object",
															title:"Dimension",
															headerTemplate:"{{self.name}}",
															options:{disable_collapse:true},
															properties:{
																	name:{title:"Name",type:"string"},
																	type:{
																			oneOf:{
																				"Date":{	
																						type:"object",
																						properties:{
																								dataFormat:{type:"string",enum:["Unix Timestamp","Date","Datetime"]}//,"Local Date"]}
																								timeframes:{
																										"type": "array",
																										"uniqueItems": true,
																										"items": {
																												"type": "string",
																												"enum": ["day","week","month","year","raw"]
																											}
																									}
																							}
																					},
																				"Other":{type:"string"}
																			}
																	}
																	sql:{title:"sql",type:"string"},
																	rest:{title:"Other LookML",type:"string",format:"textarea"}
																}
														}
												},
											"measures":{
													type:"array",
													format:"tabs",
													title:"Measures",
													items:{
															type:"object",
															title:"Measure",
															headerTemplate:"{{self.name}}",
															options:{disable_collapse:true},	
															properties:{
																	name:{title:"Name",type:"string"},
																	type:{title:"Built-in type",type:"string",enum:[
																			"Count","Sum","Average","Listagg",""
																		]},
																	sql:{title:"sql",type:"string"},
																	rest:{title:"Other LookML",type:"string",format:"textarea"}
																}
														}
												},
											"otherLookml":{title:"Other LookML", type:"string", format:"textarea"}
										}
								}
						},
					"normalizedRelationships":{
							title:"Normalized relationships",
							type:"array",
							format:"table",
							items:{
									type:"object",
									title:"Relationship",
									headerTemplate:"{{self.baseTable}} -> {{self.dimensionTable}}",
									options:{disable_collapse:true},
									properties:{
											baseTable:{type:"string",title:"Many table"},
										 	foreignKey:{type:"string",title:"Many.FK"},
											foreignKey:{type:"string",title:"One Table"},
										}
								}
						},
					"conformedRelationships":{
							title:"Conformed relationships",
							type:"array",
							items:{
									type:"object",
									title:"Relationship",
									headerTemplate:"{{self.name}}",
									options:{disable_collapse:true},
									properties:{
										name:{type:"string",title:"Name"},
										type:{type:"string",title:"Type",enum:["Date","Other"]}
										//timeframes
										//conformedColumns:{type:"array"}
									}
								}
						}	
				}
		}

	var initialValue={}
</script>
<script type="text/x-nunjucks-disabled" data-name="main">
connection: "<$ connectionName $>"
explore: <$ exploreName or "all_the_things" $> {
	hidden: yes
  
	# "Base"/"Measure" joins
	<% for view in views.filter(v=>v.measures.length) %>
	join: <$ view.table $> {
		type: full_outer
		view_label: "<$ view.label $>"
		relationship: one_to_one
		fields: [
		<$ []
			.concat(view.pk)
			.concat(view.measures.map(m=>m.name))
			.join(",\n")
		$>
		]
		<% if dialect=="BigQuery Standard" %>
		sql_on: FALSE ;;
		<% elsif x.dialect=="Redshift Standard" %>
		#Redshift (Only allows FOJ on merge joins, which require dist & sort key equality)
		sql_on: 
				<$ view.table$>.<$ view.rs.dist $> = <$ exploreName $>.base
			AND <$ view.table$>.<$ view.rs.sort $> = <$ exploreName $>.base 
			<%- for prior in views.filter((prior,p)=>prior.measures.length && p<loop.index0) -%>
			{% if <$ []
				.concat(prior.pk)
				.concat(prior.measures.map(m=>m.name))
				.map(field=>prior.name+"."+field+"._in_query")
				.join("\n or ")
			$> %}
			AND <$ view.table$>.<$ view.rs.dist $> = <$ prior.name $>.<$ prior.rs.dist $>
			AND <$ view.table$>.<$ view.rs.sort $> = <$ prior.name $>.<$ prior.rs.sort $>
			{% endif %}
			<%- endfor -%>
			;;
 		<% endif %>
	}
	<%- endfor %>

	#"Dimension table" joins
	<% for view in views.filter(v=>v.dimensions.length) %>
	join: associated_<$ view.table $> {
		view_label: "<$ view.label $>"
		#CONTINUE HERE...
	
    fields: [name]
    type: full_outer
    relationship: many_to_one
    from: products
    # This pattern is required when there are multiple levels of
    # normalization, e.g. orders -> products -> accounts.
    # Why? Looker doesn''t automatically join in associated_products
    # if a user selects something from both accounts and orders/pageviews,
    # but not from products.
    # So: I am always requiring this join if accounts is required, but it
    # changes between products or an empty select as appropriate based on
    # wheter dependent fields are in the query
    # ...Also, liquid''s boolean is basic... https://github.com/Shopify/liquid/issues/138
    sql_table_name:
    {%
      if associated_product.name._in_query
      or orders.count._in_query
      or orders.total_sales._in_query
      or pageviews.count._in_query
      or all_the_things.product_conversion_rate._in_query
      or products.count_subtotal_by_account._in_query
      %}products{%
      else
      %}
    (SELECT null as id, null as account_id FROM (SELECT NULL x) p where x IS NOT NULL)
    {% endif %};;
    sql_on: ${associated_product.id}=COALESCE({%
      if products.count._in_query
      or products.count_subtotal._in_query
      or products.name._in_query
      or products.count_subtotal_by_account._in_query
      %}
      products.id, {% endif %}{%
      if pageviews.count._in_query
      or all_the_things.product_conversion_rate._in_query
      %}
      pageviews.product_id, {% endif %}{%
      if orders.count._in_query
      or orders.total_sales._in_query
      or all_the_things.product_conversion_rate._in_query
      %}
      orders.product_id, {% endif %}
      NULL) ;;
  }
  join: associated_account {
    view_label: "Accounts"
    from: accounts
    fields: [id,employees,name]
    type: full_outer
    relationship: many_to_one
    sql_on: ${associated_account.id}=COALESCE({%
      if accounts.count._in_query
      or accounts.employees._in_query
      or accounts.name._in_query
      or accounts.total_employees._in_query
      or products.count_subtotal_by_account._in_query
      %}
      accounts.id, {% endif %}{%
      if products.count._in_query
      or products.count_subtotal._in_query
      %}
      products.account_id, {% endif %}{%
      if managers.count._in_query
      %}
      managers.account_id, {% endif %}{%
      if pageviews.count._in_query
      or orders.count._in_query
      or orders.total_sales.in_query
      or associated_product.name._in_query
      or all_the_things.product_conversion_rate._in_query
      or products.count_subtotal_by_account._in_query
      %}
      ${associated_product.account_id}, {% endif %}
      NULL);;
  }
}


view: {{= x.exploreName}} {
  view_label: "[All the things]"
  #BQ: sql_table_name: (SELECT base FROM (SELECT null as base) as btable WHERE base IS NOT NULL);;
  #Redshift (Only allows FOJ on merge joins, which require dist & sort key equality)
  derived_table: {
    sql: (SELECT base FROM (SELECT null as base) as btable WHERE base IS NOT NULL) ;;
    persist_for: "1 hour"
    distribution: "base"
    sortkeys: ["base"]
  }
  dimension: base {
    hidden: yes
    sql: ${TABLE}.base ;;
  }
  dimension_group: combined {
    type: time
    timeframes: [date,week,month]
    sql: ${combined_date_internal} ;;
  }
  dimension: combined_date_internal {
    hidden: yes
    sql: COALESCE({%
      if pageviews.count._in_query
      or all_the_things.product_conversion_rate._in_query
      %}
      pageviews.pv_date, {% endif %}{%
      if orders.count._in_query
      or orders.total_sales._in_query
      or all_the_things.product_conversion_rate._in_query
      %}
      CASE {% parameter orders.combined_date_on %}
      WHEN 'Order Date' THEN orders.order_date
      WHEN 'Shipped Date' THEN orders.shipped_date
      ELSE orders.order_date
      END, {% endif %}
      CAST(NULL as timestamp)
    );;
  }
  measure: product_conversion_rate {
    type: number
    value_format_name: decimal_3
    sql: CASE WHEN ${pageviews.count}<>0 THEN ${orders.count} / ${pageviews.count} ELSE NULL END;;
  }
}


view: accounts {
  derived_table: {
    sql:
     SELECT 1 as id, 'Acme' as name, 80 as employees
     UNION ALL
     SELECT 2 as id, 'Initech' as name, 120 as employees
    ;;
    persist_for: "1 hour"
    distribution: "id"
    sortkeys: ["id"]
  }
  dimension: id {
    hidden:  yes
    type: number
    sql: ${TABLE}.id ;;
  }
  dimension: name {
    type: string
    sql: ${TABLE}.name ;;
  }
  dimension: employees {
    type: number
    sql: ${TABLE}.employees ;;
  }
  measure: total_employees {
    type: number #Keep nulls as nulls
    sql: SUM(${employees}) ;;
  }
  measure: count {
    type: number
    sql: CASE WHEN MIN(${id}) IS NULL THEN NULL ELSE COUNT(${id}) END ;;
  }
}

view: products {
  derived_table: {
    sql:
     SELECT 1 as id, 'Rockets' as name, 1 as account_id
     UNION ALL
     SELECT 2 as id, 'Portable Holes' as name, 1 as account_id
     UNION ALL
     SELECT 3 as id, 'Synergy' as name, 2 as account_id
    ;;
    persist_for: "1 hour"
    distribution: "id"
    sortkeys: ["id"]
  }
  dimension: id {
    hidden:  yes
    type: number
    sql: ${TABLE}.id ;;
  }
  dimension: account_id {
    hidden:  yes
    type: number
    sql: ${TABLE}.account_id ;;
  }
  dimension: name {
    type: string
    sql: ${TABLE}.name ;;
  }
  measure: count {
    type: number
    sql: CASE WHEN MIN(${id}) IS NULL THEN NULL ELSE COUNT(${id}) END;;
  }
  measure: count_subtotal_by_account {
    type: number
    required_fields: [accounts.id,associated_account.id]
    sql: CASE WHEN ${accounts.id} IS NOT NULL
         THEN SUM(${count}) OVER (PARTITION BY ${associated_account.id})
         ELSE NULL END
    ;;
  }
}

view: managers {
  derived_table: {
    sql:
     SELECT 1 as id, 'Wakko' as name, 1 as account_id
     UNION ALL
     SELECT 2 as id, 'Yakko' as name, 1 as account_id
     UNION ALL
     SELECT 3 as id, 'Dot' as name, 1 as account_id
     UNION ALL
     SELECT 4 as id, 'Bill' as name, 2 as account_id
    ;;
    persist_for: "1 hour"
    distribution: "id"
    sortkeys: ["id"]
  }
  dimension: id {
    hidden:  yes
    type: number
    sql: ${TABLE}.id ;;
  }
  dimension: account_id {
    hidden:  yes
    type: number
    sql: ${TABLE}.account_id ;;
  }
  dimension: name {
    type: string
    sql: ${TABLE}.name ;;
  }
  measure: count {
    type: number
    sql: CASE WHEN MIN(${id}) IS NULL THEN NULL ELSE COUNT(${id}) END;;
  }
}

view: pageviews {
  derived_table: {
    sql:
     SELECT CAST('2017-01-02' as timestamp) as pv_date, 1 as product_id
     UNION ALL
     SELECT CAST('2017-01-15' as timestamp) as pv_date, 2 as product_id
     UNION ALL
     SELECT CAST('2017-01-24' as timestamp) as pv_date, 2 as product_id
     UNION ALL
     SELECT CAST('2017-02-02' as timestamp) as pv_date, 1 as product_id
     UNION ALL
     SELECT CAST('2017-02-02' as timestamp) as pv_date, 3 as product_id
     UNION ALL
     SELECT CAST('2017-02-02' as timestamp) as pv_date, NULL as product_id
     UNION ALL
     SELECT CAST('2017-02-21' as timestamp) as pv_date, 2 as product_id
     UNION ALL
     SELECT CAST('2017-03-02' as timestamp) as pv_date, 3 as product_id
     UNION ALL
     SELECT CAST('2017-03-02' as timestamp) as pv_date, NULL as product_id
     UNION ALL
     SELECT CAST('2017-03-15' as timestamp) as pv_date, 2 as product_id
    ;;
    persist_for: "1 hour"
    distribution: "product_id"
    sortkeys: ["pv_date"]
  }
  dimension: distkey { sql:${product_id};; hidden: yes }
  dimension: sortkey { sql:${pv_date_raw};; hidden: yes }

  dimension_group: pv_date {
    hidden:  yes
    timeframes: [raw,date,week,month,year]
    type: time
    sql: ${TABLE}.pv_date ;;
  }
  dimension: product_id {
    hidden:  yes
    type: number
    sql: ${TABLE}.product_id ;;
  }
  measure: count {
    type: number
    sql: CASE WHEN MIN(${TABLE}.pv_date) IS NULL THEN NULL ELSE COUNT(${TABLE}.pv_date) END ;;
  }
}


view: orders {
  derived_table: {
    sql:
     SELECT CAST('2017-01-02' as timestamp) as order_date, CAST('2017-01-06' as timestamp) as shipped_date, 1 as product_id, 200 as sale_price
     UNION ALL
     SELECT CAST('2017-02-02' as timestamp) as order_date, CAST('2017-02-02' as timestamp) as shipped_date,  3 as product_id, 1000 as sale_price
     UNION ALL
     SELECT CAST('2017-02-21' as timestamp) as order_date, CAST('2017-03-08' as timestamp) as shipped_date, 2 as product_id, 25 as sale_price
     UNION ALL
     SELECT CAST('2017-03-15' as timestamp) as order_date, CAST('2017-04-02' as timestamp) as shipped_date, 2 as product_id, 50 as sale_price
    ;;
    persist_for: "1 hour"
    distribution: "product_id"
    sortkeys: ["order_date"]
  }
  dimension: distkey { sql:${product_id};; hidden: yes }
  dimension: sortkey { sql:${order_date_raw};; hidden: yes }

  filter: combined_date_on {
    suggestions: ["Order Date","Shipped Date"]
  }
  dimension_group: order_date {
    timeframes: [raw,date,week,month,year]
    type: time
    sql: ${TABLE}.order_date ;;
  }
  dimension_group: shipped_date {
    timeframes: [raw,date,week,month,year]
    type: time
    sql: ${TABLE}.order_date ;;
  }
  dimension: product_id {
    hidden:  yes
    type: number
    sql: ${TABLE}.product_id ;;
  }
  dimension: sale_price {
    type: number
    value_format_name: usd
    sql: ${TABLE}.sale_price ;;
  }
  measure: count {
    type: number
    sql: CASE WHEN MIN(${TABLE}.order_date) IS NULL THEN NULL ELSE COUNT(${TABLE}.order_date) END ;;
  }
  measure: total_sales {
    type: number #Not sum because we like nulls as nulls
    sql: SUM(${sale_price}) ;;
  }
}
</script>
<script type="text/x-nunjucks" data-name="test">
 {{no.x}} <$ dialect $>
</script>
</html>
