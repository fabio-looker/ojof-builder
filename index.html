<!doctype html >
<html>
<head>
<script>var version={v:"1.1.0",date:"2017-07-04"}</script>
<title>LookML Builder</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/foundation/5.5.3/css/foundation.min.css" integrity="sha256-NTds7atVCDeolLUzbcl45lx4gJYO+hNXCaX1wC2HQHc=" crossorigin="anonymous" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/json-editor/0.7.28/jsoneditor.min.js" integrity="sha256-51+oMmpgSgS4jV5/DcGKnDHIOL6Jeie2i7ka6sPQVro=" crossorigin="anonymous"></script>
<!--<script src="https://cdnjs.cloudflare.com/ajax/libs/nunjucks/3.0.0/nunjucks.min.js" integrity="sha256-LWvp8rf/ha5W5zb5rGjypfi/b8w5Yo0Lm+W6ccH3ejA=" crossorigin="anonymous"></script>-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/dot/1.1.0/doT.min.js" integrity="sha256-0DJpUBhIByZ5Tm5u/xEvcRalEiuyadItx381FmBKHB4=" crossorigin="anonymous"></script>
<script src="https://cdn.rawgit.com/Nanonid/rison/e64af6c096fd30950ec32cfd48526ca6ee21649d/js/rison.js" integrity="sha256-4Zg2e0UX/I8JAIl4CQgnB/A15bw2jxjLCu/mjQRGoRI=" crossorigin="anonymous"></script>
<style>
 textarea{font-size:10pt !important;}
 .out {width:100%;height:20em;}
 dl.tabs.vertical>dd{overflow: hidden; text-overflow: ellipsis;max-height:4em;}
 dl.tabs.vertical>dd>a{padding:0.5rem 0.25rem;white-space: pre-line;}
 .tabs-content>div>h3{overflow: hidden; text-overflow: ellipsis;max-height:4em;white-space: pre-line;}
</style>
<script>
	// Set the JSONEditor CSS theme and icon library globally
	JSONEditor.defaults.theme = 'foundation5';
	JSONEditor.defaults.iconlib = 'fontawesome4';
	$(document).ready(()=>{
			$("#version").text("v"+version.v+" ("+version.date+")")
			var editorDef= {
					schema: inputSchema,
					startval:  tryRisonParse("o")
							|| tryJSONParse(qs("o"))
							|| tryJSONParse(localStorage.getItem(storageKey))
							|| initialValue,
					"required_by_default":true,
					//"disable_collapse":true,
					"disable_properties":true,
					"display_required_only":true,
					"keep_oneof_values":true,
					"disable_edit_json":true
				}
			var editor = new JSONEditor($("#json-editor")[0],editorDef)
			editor.on('change',function() {
					localStorage.setItem(storageKey,JSON.stringify(editor.getValue()))
					$("#msg").hide()
				});

				doT.templateSettings = {
						evaluate:    /\<\<\!([\s\S]+?)\>\>/g,
						interpolate: /\<\<\:([\s\S]+?)\>\>/g,
						encode:      /\<\<&([\s\S]+?)\>\>/g,
						use:         /\<\<#([\s\S]+?)\>\>/g,
						define:      /\<\<##\s*([\w\.$]+)\s*(\:|=)([\s\S]+?)#\>\>/g,
						conditional: /\<\<\?(\?)?\s*([\s\S]*?)\s*\>\>/g,
						iterate:     /\<\<\*\s*(?:\>\>|([\s\S]+?)\s*\:\s*([\w$]+)\s*(?:\:\s*([\w$]+))?\s*\>\>)/g,
						varname: 'x',
						strip: false,
						append: true,
						selfcontained: false
					};
			var templates={}
			$("script[type='text/x-dot-template']").each(function(i,el){
					var t=this.dataset;
					//templates[t.name]=nunjucks.compile($(this).text(),env)
					templates[t.name]=doT.template($(this).text())
					$("#out").append("<h2>"+(t.label||t.name)+"</h2><textarea readonly='readonly' class='out' data-name='"+t.name+"'></textarea>")
				})

			$("#text-out").focus(function(){
					// Highlight all on select
					// Solution per http://stackoverflow.com/a/24589806
					$(this).on("click.a keyup.a", function(e){
							$(this).off("click.a keyup.a").select();
						});
				});



			$("#build-form").on("submit",function(evt){
					evt.preventDefault();
					$("#msg").hide();
					var errs=editor.validate();
					if(errs.length){
							$("#msg")
							.text(errs.map(e=>e.path+": "+e.message).join("\n"))
							.show()
							return;
						}
					var editorValue=editor.getValue()
					console.log("Editor", editorValue)
					var input=customTransform(editorValue)
					console.log("transformed", input)
					$(".out").each(function(i,el){
							try{
									$(this).val(templates[this.dataset.name](input).replace(/\n\s*\n/g,"\n"))
								}catch(e){
									console.error(e)
								}
						})
				})
		})

	//Just functions below

	function set(obj,path,val){
			if(path.split){path=path.split('.')}
			var head=path[0];
			if(path.length==1){
					obj[head]=val
				}else{
					obj[head]=obj[head]||{};
					set(obj[head],path.slice(1),val)
				}
			return obj;
		}
	function get(obj,path){
			if(path.split){path=path.split('.')}
			var head=path[0];
			if(path.length==1){
					return obj && obj[head];
				}else{
					return get(obj[head],path.slice(1))
				}
		}
	function unique(x,i,a){return a.indexOf(x)===i}
	function not(f){return function(...argArr){return !f(...argArr)}}
	function flatten(a,b){return a.concat(b)}
	function truthy(x){return !!x}
	function objByOf(byKeys,ofKey){
			byKeys=(byKeys instanceof Array ? byKeys : [byKeys])
			return function(accum,x,i){
					return set(accum,byKeys.map(k=>get(x,k)),ofKey?get(x,ofKey):x)
				}
		}
	function sorter(path){
			return function(a,b){
					return get(a,path)-get(b,path)
				}
		}
	function tryJSONParse(s){
			try{
					return JSON.parse(s)
				}catch(e){
					return undefined
				}
		}
	function tryRisonParse(s){
			try{
					rison.decode(s)
				}catch(e){
					return undefined
				}
		}
	function qs(k){
			return document.location.search.slice(1).split("&")
			.filter(function(p){return p.indexOf(encodeURIComponent(k)+"=")===0})
			.map(function(p){return decodeURIComponent(p.split("=").slice(1).join("="))})[0]
		}
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-96247573-1', 'auto');
  ga('set', 'checkProtocolTask', null); // Disable file protocol checking.
  ga('set', 'checkStorageTask', null); // Disable cookie storage checking.
  ga('set', 'historyImportTask', null); // Disable history checking (requires reading from cookies).
  ga('send', 'pageview');

</script>
</head>
<body>
	<div id="version" style="position:absolute;top:0;right:1em;color:#DDD;font-size:0.8em"></div>
	<h1>LookML Builder</h2>
	<div>
		<div id="build-panel" style="width:80vw;min-width:640px;margin:0 auto">
			<form id="build-form" onsubmit="return false">
				<div id="json-editor"></div>
				<div id="msg" style="white-space:pre-line;color:#333;background-color:#DDB"></div>
				<div style="text-align:right">
					<div  style="display:inline-block;vertical-align:top;margin: 0 2em;">
						<input type="submit" style="margin-left:auto;margin-right:auto;border:solid 1px black" value="Go" class="button" />
					</div>
				</div>
			</form>
		</div>
		<div style="max-width:640px;margin:0 auto">
			<h2>Tips</h2>
			<ul style="font-size:0.8em; font-family:serif; color:#333;">
				<li> This is a static HTML file and can be used locally. If you are running it from a shared domain, other scripts on that domain may have access to data you enter here.</li>
			</ul>
		</div>
		<div style="width:80vw;min-width:640px;margin:0 auto">
			<h2>Built Model</h2>
			<div id="out"></div>
		</div>
	</div>
</body>
<!-- Input schema-->
<script>
	var storageKey="json-outerjoinonfalse"
	var pat={
			sql:"^[^;]+(;[^;]+)*$",
			oneLineString:"^[^\"\\n]+$",
			oneLineStringOrNone:"^[^\"\\n]*$",
			multiLineStringPattern:"^[^\"]+$",
			atom:"^[a-zA-Z0-9_]+$",
			atomOrNone:"^[a-zA-Z0-9_]*$"
		}
	var inputSchema={
			type:"object",
			title:"LookML Builder Form",
			options:{"disable_edit_json":false,"disable_properties":false,"remove_empty_properties":true,"display_required_only":true},
			properties:{
					"connectionName":{
							title:"Name of your connection",
							type:"string",
							pattern:pat.oneLineStringOrNone
						},
					"dialect":{
							title:"SQL Dialect",
							type:"string",
							enum:["BigQuery Standard","Redshift"]
						},
					"explore":{
							type:"object",
							title:"Explore",
							options:{disable_edit_json:true,disable_properties:true,display_required_only:true},
							properties:{
									label:{
											title:"Label",
											type:"string",
											pattern:pat.oneLineString
										},
									other:{
											title:"Other LookML",
											type:"string",
											format:"textarea"
										}
								}
						},
					"codims":{
							title:"Conformed Dimensions",
							type:"array",
							format:"tabs",
							//options:{},
							items:{
									type:"object",
									title:"CoDim",
									headerTemplate:"{{self.label}}",
									options:{disable_collapse:true},
									properties:{
											label:{type:"string",title:"Label"},
											viewLabel:{
													type:"string",
													title:"Dispay in view",
													watch:{views:"views"},
													enumSource:[{
															source:["[Base view]"]
														},{
															source:"views",
															title:"{{item.label}}",
															value:"{{item.label}}"
														}]
												},
											type:{type:"string",title:"Type",enum:[
													"",
													"date",
													"string",
													"number"
													//,"yesno" helltool/issues/13948
												]}
										}
								}
						},
					"views":{
							title:"Views",
							type:"array",
							format:"tabs",
							items:{
									type:"object",
									title:"View",
									headerTemplate:"{{self.label}}\n{{self.table}}",
									options:{disable_collapse:true},
									properties:{
											"label":{title:"Label",type:"string", pattern:pat.oneLineString},
											"table":{title:"Table",type:"string", pattern:pat.sql},
											"pk":{
													type:"object",
													title:"Primary Key",
													properties:{
															key:{title:"Key",type:"string", pattern:pat.atom}, //v2: Comma-separated atoms
															dim:{type:"boolean",format:"checkbox",title:"Dimension"},
															count:{type:"boolean",format:"checkbox",title:"Count"}
														}
												},
											"rs":{
													type:"object",
													format:"compact",
													title:"[Redshift only]",
													properties:{
															dist:{title:"Dist key",type:"string", pattern:pat.atomOrNone},
															distgroup:{title:"Dist group",type:"string", pattern:pat.atomOrNone},
															sort:{title:"Sort key",type:"string", pattern:pat.atomOrNone}
														}
												},
											"fields":{
													type:"array",
													format:"tabs",
													title:"Fields",
													items:{
															type:"object",
															title:"Field",
															headerTemplate:"{{self.label}}",
															options:{disable_collapse:true},
															properties:{
																	label:{propertyOrder:1,title:"Label",type:"string", pattern:pat.oneLineString},
																	sql:{propertyOrder:2,title:"SQL",type:"string", pattern:pat.sql},
																	type:{propertyOrder:3,title:"Datatype",type:"string",enum:["","string","number","date"/*,"yesno" helltool/issues/13948 */]},
																	dim:{propertyOrder:4,type:"boolean",format:"checkbox",title:"Dimension"},
																	sum:{propertyOrder:6,type:"boolean",format:"checkbox",title:"Sum"},
																	avg:{propertyOrder:7,type:"boolean",format:"checkbox",title:"Average"},
																	min:{propertyOrder:8,type:"boolean",format:"checkbox",title:"Min"},
																	max:{propertyOrder:9,type:"boolean",format:"checkbox",title:"Max"},
																	list:{propertyOrder:10,type:"boolean",format:"checkbox",title:"List"},
																	codim:{propertyOrder:11,
																			type:"string",
																			title:"Conformed Dimension",
																			watch:{codims:"codims"},
																			enumSource:[{
																					"source": [{"value": "","title": ""}],
																					"title": "{{item.title}}",
																					"value": "{{item.value}}"
																				},{
																					source:"codims",
																					title:"{{item.label}}",
																					value:"{{item.label}}_{{i}}"
																				}]
																		},
																	"otherLookml":{propertyOrder:1001,title:"Other LookML", type:"string", format:"textarea"}
																}
														}
												}
										}
								}
						},
					"normalizedRelationships":{
							title:"Normalized relationships",
							type:"array",
							format:"table",
							options:{disable_array_delete_last_row:true,disable_array_delete_all_rows:true,disable_array_reorder:true},
							items:{
									type:"object",
									properties:{
											leftViewName:{
													type:"string",
													title:"\"Many\" Table",
													options:{input_width:"12em"},
													watch:{views:"views"},
													enumSource:[{
															source:"views",
															title:"{{item.label}} ({{item.table}})",
															value:"{{item.label}}_{{i}}"
														}]
												},
										 	foreignKey:{
													type:"string",
													title:"ManyTable.FK",
													options:{input_width:"28em"},
													pattern:pat.atom
												},
											rightViewName:{
													type:"string",
													title:"\"One\" Table",
													options:{input_width:"12em"},
													watch:{views:"views"},
													enumSource:[{
															source:"views",
															title:"{{item.label}} ({{item.table}})",
															value:"{{item.label}}_{{i}}"
														}]
												}
										}
								}
						}
						,
					"timeframes":{
							title:"Timeframes",
							type:"array",
							uniqueItems:true,
							items:{
									type:"string",
									enum:[
											"year",
											"month",
											"week",
											"date",
											"hour",
											"hour_of_day",
											"day_of_week",
											"month_of_year"
										]
								}
						}
					/*,
					"pdtPersistence":{
							title:"PDT Persistence (if any)",
							type:"string",
							pattern:"^$|^persist_for:\\s*\"\\d+\\s+(hours?|days?|minutes?)\"$|^sql_trigger_value:[^;]*(;[^;]*)*;;$"
						}*/
				}
		}

	var initialValue = {
			"explore": {
					"label": "All the things",
					"other": "always_filter:{ filters:{\n  field: combined_date_0_date\n  value: \"7 days,NULL\"\n}}"
				},
			"codims": [
					{
							"label": "Combined Date",
							"viewLabel": "[Base view]",
							"type": "date"
						}
				]
		};

	function customTransform (x){
			var pdtRegex=/^\s*\$\{([a-zA-Z_][a-zA-Z0-9_$]*)\.SQL_TABLE_NAME\}\s*$/
			var singleColRegex=/^[_a-zA-Z][_a-zA-Z0-9$]*$|^"[^"]+"$/
			return Object.assign({},x,{
					generator:version,
					original:x,
					explore:Object.assign({},x.explore,{
							name:lookmlName(x.explore.label)
						}),
					views:x.views.map((v,vi)=>Object.assign({},v,{
							n:vi,
							name:lookmlName(v.label)+"_"+vi,
							//Deprecated
							// mName:lookmlName(v.label)+"_"+vi+"m",
							// dName:lookmlName(v.label)+"_"+vi+"d",
							//To
							//Base Table: Used in the table view's name
							bTable: lookmlName(v.label)+"_"+vi+"_tbl",
							//Measure table: Join alias for the table view for measure fields
							mTable: lookmlName(v.label)+"_"+vi+"_msr_tbl",
							//Dimension table: Join alias of the base table for dimension fields
							dTable: lookmlName(v.label)+"_"+vi+"_dim_tbl",
							//Measure fields: View name (& implicit join name) for the measure fields
							mFields: lookmlName(v.label)+"_"+vi+"_msr_fld",
							//Dimension fields: View name (& implicit join name) for the dimension fields
							dFields: lookmlName(v.label)+"_"+vi+"_dim_fld",
							//Join alias for dimension "conditional gate" join
							dConditional: lookmlName(v.label)+"_"+vi+"_dim_cnd",

							isTableRef:!!v.table.match(/^\s*[a-zA-Z_][a-zA-Z0-9_$]*(\.[a-zA-Z_][a-zA-Z0-9_$]*)?\s*$/),
							tableType:
									v.table.match(/^\s*[a-zA-Z_][a-zA-Z0-9_$]*(\.[a-zA-Z_][a-zA-Z0-9_$]*)?\s*$/)
									? "table"
									: v.table.match(pdtRegex)
									? "pdt"
									: "sql",
							pdtName:(v.table.match(pdtRegex)||[])[1]
						})).map((v,vi)=>Object.assign({},v,{
							fields:v.fields.map((f,fi)=>Object.assign({},f,{
									n:fi,
									viewName:v.name,
									name:lookmlName(f.label)+"_"+fi,
									dim:f.dim && f.type!="date",
									ddg:f.dim && f.type=="date",
									codim:f.codim?lookmlName(f.codim):undefined,
									sql:(f.sql||'').match(singleColRegex)
										?"${TABLE}."+f.sql
										:f.sql
								})).map((f,fi)=>Object.assign({},f,{
									bSql:f.sql.replace(/\$\{TABLE\}/g, v.bTable),
									mSql:f.sql.replace(/\$\{TABLE\}/g, v.mTable),
									dSql:f.sql.replace(/\$\{TABLE\}/g, v.dTable)
								}))
						})),
					normalizedRelationships:x.normalizedRelationships.map((r,ri)=>Object.assign({},r,{
							leftViewName:lookmlName(r.leftViewName),
							rightViewName:lookmlName(r.rightViewName),
						})),
					codims:x.codims.map((c,ci)=>Object.assign({},c,{
							n:ci,
							name:lookmlName(c.label)+"_"+ci
						}))
				});
		}
		function lookmlName(s){
				if(!s || !s.trim || !s.trim()){throw "Non-empty string required for LookML name";}
				return s.replace(/[\s]+/g,"_").replace(/[^a-zA-Z0-9_]+/g,"").toLowerCase()
			};

</script>
<script type="text/x-dot-template" data-name="main">
	<<!
	function viewFromName(name){return x.views.find(v=>v.name==name)};
	function righterViews(baseView) {
			return viewsInDirection(baseView,"right",10)
		};
	function lefterViews(baseView){
			return viewsInDirection(baseView,"left",10)
		};
	function rightViews(baseView) {
			return viewsInDirection(baseView,"right",1)
		};
	function leftViews(baseView){
			return viewsInDirection(baseView,"left",1)
		};
	function viewsInDirection(baseView,direction,depth){
			var baseViewName=typeof baseView == "string" ? baseView : baseView.name;
			return recurNamesInDirection(baseViewName,direction,depth).filter(unique).map(viewFromName);
	};
	function recurNamesInDirection(baseViewName,dir,remainingRecursion){
			var oppDir=(dir=="left"?"right":"left");
			var immediateViewNames
					=x.normalizedRelationships
					.filter(rel=>rel[oppDir+"ViewName"]==baseViewName)
					.map(rel=>rel[dir+"ViewName"]);
			return (immediateViewNames.length && remainingRecursion
					? immediateViewNames.map(p=>recurNamesInDirection(p,dir,remainingRecursion-1)).reduce(flatten,immediateViewNames)
					: []
				);
		};
	function sqlString(s){
			switch (x.dialect){
					case 'Redshift': /* ??? Thanks Amazon.... http://docs.aws.amazon.com/redshift/latest/dg/r_Literals.html */
					case 'BigQuery Standard': /* https://cloud.google.com/bigquery/docs/reference/standard-sql/lexical#string-and-bytes-literals */
							return "'"+(s||'').replace(/\\/g,"\\\\").replace(/'/g,"\\'")+"'"
				}
		};
	function measureNames(view){
			return (["sum","avg","min","max","list"]
					.map(measureType=>view.fields.map(field=>field[measureType] && measureType+"_"+field.name))
					.reduce(flatten,["count_pk"])
					.filter(truthy)
				)
		}
	function dimensionNames(viewOrField){
			return (
					[{flag:"dim", prefix:"dim_", suffix:""}]
					.concat(x.timeframes.map(t=>({flag:"ddg", prefix:"ddg_", suffix:"_"+t})))
					.map(dimensionType=>
							(viewOrField.fields || [viewOrField])
							.map(field=>
									field[dimensionType.flag] && dimensionType.prefix+field.name+dimensionType.suffix
								)
						)
					.reduce(flatten,["dim_pk"])
					.filter(truthy)
				)
		};
	function codimNames(codim){
			return (codim.type!="date"
					? [codim.name]
					: x.timeframes.map(t=>codim.name+"_"+t)
				);
		};
	/*
	function measurePaths(view){
			return measureNames(view).map(field=>view.mTable+"."+field)
		};
	function dimensionPaths(viewOrField){
			return dimensionNames(viewOrField).map(field=>view.dName+"."+field)
		};
	function fieldPaths(view){
			return measurePaths(view).concat(dimensionPaths(view))
		}*/
	>>
	# Warning:  This file is programatically generated (Your changes will be overwritten)
	# OJOF Generator by Fabio
	# Generator v<<:x.generator.v>> (<<:x.generator.date>>)
	# Generated on <<:(new Date()).toISOString().slice(0,10)>>
	# https://fabio-looker.github.io/ojof-builder/?o=<<:rison.encode_uri(x.original)>>

	<<?x.connectionName>>connection: "<<:x.connectionName>>"<<?>>
	explore: <<:x.explore.name>> {
		label:"<<:x.explore.label>>"

		# "Measure" joins
		<<* x.views :view:v >>
		join: <<:view.mTable>> {
			from: <<:view.bTable>>
			type: full_outer
			relationship: one_to_one
			<<? x.dialect=="BigQuery Standard" >>
			sql_on: FALSE ;;
			<<?? x.dialect=="Redshift" >>
			#Redshift (Only allows FOJ on merge joins, which require dist & sort key equality)
			sql_on: /**/
				    <<:view.mTable>>.<<:view.rs.dist>> = ${<<:x.explore.name>>.base}
				AND <<:view.mTable>>.<<:view.rs.sort>> = ${<<:x.explore.name>>.base}
				<<* x.views.filter(prior=>prior.n<view.n) :prior:p >>
				{%  if <<:prior.mFields>>._in_query or <<:prior.dFields>>._in_query %}
				AND <<:view.mTable>>.<<:view.rs.dist>> = <<:prior.mTable>>.<<:prior.rs.dist>>
				AND <<:view.mTable>>.<<:view.rs.sort>> = <<:prior.mTable>>.<<:prior.rs.sort>>
				{% endif %}
				<<*>>
			;;
	 		<<?>>
		}
		join: <<:view.mFields>> {
			sql: ;;
			required_joins:[<<:view.mTable>>]
			relationship: one_to_one
		}
		<<*>>

		#Selected "Dimension table" joins
		<<* x.views :view:v >>
		join: <<:view.dConditional>> {# "conditional" join
			from: nothing
			relationship: one_to_one
			required_joins:[
				<<* lefterViews(view) :left:l>> <<?l!=0>>,<<?>><<:left.dTable>> <<*>>
			]
			sql:{%	if <<:view.mFields>>._in_query
				 	or <<:view.dFields>>._in_query
					<<* lefterViews(view) :left:l>>
					or <<:left.mFields>>._in_query
					or <<:left.dFields>>._in_query
					<<*>>
				%}			/* Allow <<:view.dTable>> */
				{% else %}	/* Prevent <<:view.dTable>> {% endif %}{% if '1'=='0' %}*/
				{% endif %}
			;;
		}
		join: <<:view.dTable>> {
			from: <<:view.bTable>>
			type: left_outer
			relationship: many_to_one
			required_joins:[ <<:view.dConditional>> ]
			sql_on: <<:view.dTable>>.<<:view.pk.key>> =
				COALESCE(
					{%	if <<:view.mFields>>._in_query or <<:view.dFields>>._in_query %}
						--Own view has dims or measures selected, so self.mView will be joined. Include via pk
						<<:view.mTable>>.<<:view.pk.key>>,
					{% endif %}
				<<* leftViews(view) :leftView>>
					{%	if <<:leftView.mFields>>._in_query or <<:leftView.dFields>>._in_query
						<<* lefterViews(leftView) :lefterView>>
						or <<:lefterView.mFields>>._in_query or <<:lefterView.dFields>>._in_query
						<<*>>
					%}
					--Parent view fields selected, so parent.dView will be joined. Include via fk
					--or ancestor view has dims or measures selected, so parent.dView will be joined. Include via fk
					<<:leftView.dTable>>.<<:x.normalizedRelationships.find(r=>
							r.leftViewName==leftView.name && r.rightViewName==view.name
						).foreignKey>>,
					{% endif %}
				<<*>>
					NULL
				)
			<<? x.dialect=="Redshift" && view.rs.distgroup >>
			--Distkey equality (unless incompatible parents are in query)
			{%	unless '0'=='1'
				<<* leftViews(view) :parentView>>
				<<? parentView.rs.distgroup != view.rs.distgroup >>
				or <<:parentView.mFields>>._in_query
				or <<:parentView.dFields>>._in_query
				<<?>>
				<<*>>
			%}
			AND <<:view.dTable>>.<<:view.rs.dist>> =
				COALESCE(
					{%	if <<:view.mFields>>._in_query or <<:view.dFields>>._in_query %}
						--Own view has dims or measures selected, so self.mView will be joined. Include via dk
						<<:view.mTable>>.<<:view.rs.dist>>,
					{% endif %}
				<<* leftViews(view) :parentView>>
					{%	if <<:parentView.mFields>>._in_query or <<:parentView.dFields>>._in_query
						<<* lefterViews(parentView) :lefterView:l>>
						or <<:lefterView.mFields>>._in_query or <<:lefterView.dFields>>._in_query
						<<*>>
					%}
					--Parent view fields selected, so parent.dView will be joined. Include via dk
					--or ancestor view has dims or measures selected, so parent.dView will be joined. Include via dk
					<<:parentView.dTable>>.<<:parentView.rs.dist>>,
					{% endif %}
				<<*>>
					NULL
				)
			{% endunless %}
			<<?>>
			-- End conditional join */
			;;
		}
		join: <<:view.dFields>>{
			sql: ;;
			required_joins:[<<:view.dTable>>]
			relationship: one_to_one
		}
		<<*>>
		<<:x.explore.other>>
	}

	view: nothing {}
	#"Base" (empty) View
	view: <<:x.explore.name>> {
		view_label: "[<<:x.explore.label>>]"
		<<? x.dialect=="BigQuery Standard">> #BQ
		sql_table_name: (SELECT base FROM (SELECT null as base) as basetable WHERE base IS NOT NULL);;
		<<?? x.dialect=="Redshift">> #Redshift
		derived_table: {
			sql: (SELECT base FROM (SELECT null as base) as basetable WHERE base IS NOT NULL) ;;
			persist_for: "120 hours"
			distribution: "base"
			sortkeys: ["base"]
		}
		<<?>>
		dimension: base {
			hidden: yes
			sql: ${TABLE}.base ;;
		}
		<<* x.codims :codim:c>>
		<<? codim.type=="date">>dimension_group<<??>>dimension<<?>>: <<:codim.name>> {
				view_label: <<? codim.viewLabel=="[Base view]">>"[<<:x.explore.label>>]"<<??>>"<<:codim.viewLabel>>"<<?>>
				<<? codim.type=="date">>
				type: time
				timeframes: [<<:x.timeframes.join(",")>>]
				group_label: "<<:codim.label>>"
				label: " "
				<<??>>
				<<?codim.type>>type: <<:codim.type>><<?>>
				label: "<<:codim.label>>"
				<<?>>
				sql: COALESCE(
					<<* x.views :view:v>>
					<<* view.fields :field:f>>
						<<? field.codim == codim.name >>
							{%	if <<:view.dFields>>._in_query
								<<* lefterViews(view) :left:l>>
								or <<:left.dFields>>._in_query
								<<*>>
							%}
							{%	if <<:view.dFields>>._in_query
								<<* righterViews(view) :right:r>>
								or <<:right.dFields>>._in_query
								<<*>>
							%}
								<<? view.fields.filter(field2=>field2.codim==field.codim).length>1 >>
									CASE WHEN	{% condition <<:view.dFields>>.codim_switch_<<:codim.name>> %}
												<<:sqlString(field.label)>>
												{% endcondition %}
										 THEN	<<:field.dSql>>
										 ELSE NULL
									END,
								<<??>>
									<<:field.dSql>>,
								<<?>>
							{% endif %}
							{% endif %}
							{%	if <<:view.mFields>>._in_query
								<<* lefterViews(view) :left:l>>
								or <<:left.mFields>>._in_query
								<<*>>
							%}
							{% if <<:view.mFields>>._in_query
								<<* righterViews(view) :right:r>>
								or <<:right.mFields>>._in_query
								<<*>>
							%}
								<<? view.fields.filter(field2=>field2.codim==field.codim).length>1 >>
									CASE WHEN	{% condition <<:view.dFields>>.codim_switch_<<:codim.name>> %}
												<<:sqlString(field.label)>>
												{% endcondition %}
										 THEN <<:field.mSql>>
										 ELSE NULL
									END,
								<<??>>
									<<:field.mSql>>,
								<<?>>
							{% endif %}
							{% endif %}
						<<?>>
					<<*>>
					<<*>>
					NULL
				);;
			}
		<<*>>

		# Maybe add this pattern to the generator too?
		#
		#measure: product_conversion_rate {
		#	type: number
		#	value_format_name: decimal_3
		#	sql: CASE WHEN ${pageviews.count}<>0 THEN ${orders.count} / ${pageviews.count} ELSE NULL END;;
		#}
		#
	}

	#####################################
	#
	#    "REAL" VIEWS
	#
	#####################################
	<<* x.views :view >>
	view: <<:view.bTable>> {
		derived_table: {
			sql:
				SELECT *
				FROM <<:view.table>> as <<:view.bTable>>
				WHERE 1=1
				<<* view.fields :field:f>>
					<<!/* Push dimension filters onto the associated measure tables */>>
					<<* dimensionNames(field) :dim:d>>
							{% if <<:view.dFields>>.<<:dim>>._is_filtered %}
								AND {% condition <<:view.dFields>>.<<:dim>> %} <<:field.bSql>> {% endcondition %}
							{% endif %}
					<<*>>
					<<!/* Push codim filters onto the associated dimension and measure tables */>>
					<<* x.codims :codim:c>>
						<<? field.codim == codim.name >>
						<<* codimNames(codim) :typedName:t>>
							{% if <<:x.explore.name>>.<<:typedName>>._is_filtered %}
								<<? view.fields.filter(field2=>field2.codim==field.codim).length>1 >>
								AND CASE
									WHEN {% condition <<:view.dFields>>.codim_switch_<<:codim.name>> %}
										 <<:sqlString(field.label)>>
										 {% endcondition%}
									THEN {% condition <<:x.explore.name>>.<<:typedName>> %}
										 <<:field.bSql>>
										 {% endcondition %}
									ELSE 1=1 END
								<<??>>
								AND {% condition <<:x.explore.name>>.<<:typedName>> %}
									<<:field.bSql>>
									{% endcondition %}
								<<?>>
							{% endif %}
						<<*>>
						<<?>>
					<<*>>
				<<*>>
			;;
		}
	}
	view: <<:view.mFields>> {
		label: "<<:view.label>>"
		<<?x.dialect=="Redshift">>
		dimension: dist{
			hidden: yes
			sql:<<:view.mTable>>.<<:view.rs.dist>>;;
		}
		dimension: sort{
			hidden: yes
			sql:<<:view.mTable>>.<<:view.rs.sort>>;;
		}
		<<?>>
		dimension: require {
			hidden:yes
			sql: ;;
		}
		dimension: pk {
			hidden: yes
			sql: <<:view.mTable>>.<<:view.pk.key>>;;
		}

		measure: count_pk {
			hidden: <<:view.pk.count ? "no" : "yes">>
			label: "<<:view.label>> Count"
			type: number
			sql: CASE WHEN MIN(${pk}) IS NULL THEN NULL ELSE COUNT(${pk}) END ;;
		}
		<<*view.fields :field>>
		<<?field.sum>>
		measure: sum_<<:field.name>> {
			type: number
			label: "Sum of <<:field.label>>"
			sql: SUM(<<:field.mSql>>) ;;
			<<:field.otherLookml>>
		}
		<<?>>

		<<?field.avg>>
		measure: avg_<<:field.name>> {
			type: number
			label: "Average of <<:field.label>>"
			sql: AVG(<<:field.mSql>>) ;;
			<<:field.otherLookml>>
		}
		<<?>>

		<<?field.min>>
		measure: min_<<:field.name>> {
			type: <<:field.type>>
			<<?field.type=="date">>
			label: "Earliest <<:field.label>>"
			<<??>>
			label: "Max of <<:field.label>>"
			<<?>>
			sql: MIN(<<:field.mSql>>) ;;
			<<:field.otherLookml>>
		}
		<<?>>

		<<?field.max>>
		measure: max_<<:field.name>> {
			type: <<:field.type>>
			<<?field.type=="date">>
			label: "Latest <<:field.label>>"
			<<??>>
			label: "Max of <<:field.label>>"
			<<?>>
			sql: MAX(<<:field.mSql>>) ;;
			<<:field.otherLookml>>
		}
		<<?>>

		<<?field.list>>
		measure: list_<<:field.name>> {
			type: string
			label: "List of <<:field.label>>"
			<<? x.dialect=="Redshift">>sql: LISTAGG(<<:field.mSql>>,', ') ;;<<?>>
			<<? x.dialect=="BigQuery Standard">>sql: GROUP_CONCAT(<<:field.mSql>>) ;;<<?>>
			<<:field.otherLookml>>
		}
		<<?>>
		<<*>>
	}
	view: <<:view.dFields>> {
		label: "<<:view.label>>"
		dimension: pk {
			hidden: yes
			sql: <<:view.dTable>>.<<:view.pk.key>>;;
		}
		dimension: dim_pk {
			hidden: <<:view.pk.dim ? "no" : "yes">>
			label: "<<:view.label>> ID"
			sql: <<:view.dTable>>.<<:view.pk.key>>  /* ${<<:view.mFields>>.require}*/;;
		}
		<<* view.fields :field>>
		<<?field.dim>>
		dimension: dim_<<:field.name>> {
			<<?field.type>>type: <<:field.type>><<?>>
			label: "<<:field.label>>"
			sql: <<:field.dSql>> /* ${<<:view.mFields>>.require}*/;;
			<<:field.otherLookml>>
		}
		<<?>>
		<<?field.ddg>>
		dimension_group: ddg_<<:field.name>> {
			group_label: "<<:field.label>>"
			label: " "
			type: time
			timeframes: [<<:x.timeframes.join(",")>>]
			sql: <<:field.dSql>>  /* ${<<:view.mFields>>.require}*/;;
			<<:field.otherLookml>>
		}
		<<?>>
		<<*>>
		#
		# Codim selector(s)
		#
		set: codim_selectors{
			fields:[
			<<* x.codims :codim:c>>
			<<? view.fields.filter(f=>f.codim==codim.name).length>1 >>
			<<?c>0>>,<<?>> codim_switch_<<:codim.name>>
			<<?>>
			<<*>>
			]
		}
		<<* x.codims :codim:c>>
			<<? view.fields.filter(f=>f.codim==codim.name).length>1 >>
			filter: codim_switch_<<:codim.name>> {
				label: "<<?codim.type=='date'>>Date<<??>>Field<<?>> for <<:codim.label>>"
				type: string
				suggestions: ["<<:view.fields.filter(f=>f.codim==codim.name).map(f=>f.label).join('","')>>"]
			}
			<<?>>
		<<*>>

	}
	<<*>>
</script>
</html>
